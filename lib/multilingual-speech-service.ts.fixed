import { debounce } from 'lodash';

export interface SpeechServiceConfig {
  language?: string;
  continuous?: boolean;
  interimResults?: boolean;
  maxAlternatives?: number;
  onResult?: (event: SpeechRecognitionEvent) => void;
  onError?: (event: SpeechRecognitionEvent) => void;
  onEnd?: () => void;
  onStart?: () => void;
}

/**
 * Enhanced Speech Recognition Service
 * Provides multilingual speech recognition with error handling and
 * protection against "recognition has already started" errors
 */
export class MultilingualSpeechService {
  private recognition: SpeechRecognition | null = null;
  private isRecognitionActive = false;
  private language: string;
  private continuous: boolean;
  private interimResults: boolean;
  private maxAlternatives: number;
  private onResult?: (event: SpeechRecognitionEvent) => void;
  private onError?: (event: SpeechRecognitionEvent) => void;
  private onEnd?: () => void;
  private onStart?: () => void;
  private restartCount: number = 0;
  private maxRestarts: number = 3;
  
  // Support detection for browser compatibility
  private static speechRecognitionSupported(): boolean {
    return 'SpeechRecognition' in window || 
           'webkitSpeechRecognition' in window ||
           'mozSpeechRecognition' in window || 
           'msSpeechRecognition' in window;
  }
  
  // Safe access to SpeechRecognition constructor across browsers
  private static getSpeechRecognitionConstructor(): any {
    return window.SpeechRecognition || 
           (window as any).webkitSpeechRecognition ||
           (window as any).mozSpeechRecognition ||
           (window as any).msSpeechRecognition;
  }
  
  constructor(config: SpeechServiceConfig = {}) {
    // Configure default and custom settings
    this.language = config.language || 'en-US';
    this.continuous = config.continuous !== undefined ? config.continuous : true;
    this.interimResults = config.interimResults !== undefined ? config.interimResults : true;
    this.maxAlternatives = config.maxAlternatives || 1;
    this.onResult = config.onResult;
    this.onError = config.onError;
    this.onEnd = config.onEnd;
    this.onStart = config.onStart;
    
    // Initial recognition object will be created on first start
    this.recognition = null;
    this.isRecognitionActive = false;
  }

  /**
   * Start speech recognition with error handling
   * Creates a fresh recognition instance each time to avoid "already started" errors
   */
  public startRecognition(): boolean {
    try {
      console.log('üé§ Starting speech recognition...');
      
      // Check for browser support
      if (!MultilingualSpeechService.speechRecognitionSupported()) {
        console.error('‚ùå Speech recognition not supported in this browser');
        return false;
      }
      
      // CRITICAL: Always stop any existing recognition first to avoid "already started" errors
      if (this.recognition) {
        console.log('‚ö†Ô∏è Existing recognition instance found, cleaning up first...');
        this.cleanupExistingRecognition();
      }
      
      // Create a fresh instance every time
      const SpeechRecognition = MultilingualSpeechService.getSpeechRecognitionConstructor();
      this.recognition = new SpeechRecognition();
      
      // Configure the recognition object
      this.recognition.lang = this.language;
      this.recognition.continuous = this.continuous;
      this.recognition.interimResults = this.interimResults;
      this.recognition.maxAlternatives = this.maxAlternatives;
      
      // Set up event handlers
      this.recognition.onresult = (event) => {
        if (this.onResult) this.onResult(event);
      };
      
      this.recognition.onerror = (event) => {
        console.error('üîä Speech recognition error:', event);
        if (this.onError) this.onError(event);
        
        // Handle auto-restart for certain errors
        if (event.error === 'network' && this.restartCount < this.maxRestarts) {
          console.log(`üîÑ Attempting restart after network error (${this.restartCount + 1}/${this.maxRestarts})...`);
          this.restartCount++;
          this.restartRecognition();
        }
      };
      
      this.recognition.onend = () => {
        console.log('üé§ Speech recognition ended');
        this.isRecognitionActive = false;
        if (this.onEnd) this.onEnd();
      };
      
      this.recognition.onstart = () => {
        console.log('üé§ Speech recognition started');
        this.isRecognitionActive = true;
        this.restartCount = 0; // Reset restart counter on successful start
        if (this.onStart) this.onStart();
      };
      
      // Finally, start the recognition
      this.recognition.start();
      return true;
    } catch (error) {
      console.error('‚ùå Failed to start speech recognition:', error);
      this.isRecognitionActive = false;
      return false;
    }
  }
  
  /**
   * Clean up any existing recognition instance
   * This helps prevent "already started" errors
   */
  private cleanupExistingRecognition(): void {
    try {
      if (this.recognition) {
        // Remove all event handlers to prevent memory leaks
        this.recognition.onresult = null;
        this.recognition.onerror = null;
        this.recognition.onend = null;
        this.recognition.onstart = null;
        
        // Try to abort/stop the recognition
        if (this.isRecognitionActive) {
          try {
            this.recognition.abort();
          } catch (abortError) {
            try {
              this.recognition.stop();
            } catch (stopError) {
              console.warn('‚ö†Ô∏è Could not abort/stop existing recognition');
            }
          }
        }
        
        // Nullify the reference
        this.recognition = null;
        this.isRecognitionActive = false;
      }
    } catch (error) {
      console.warn('‚ö†Ô∏è Error cleaning up recognition:', error);
      // Ensure we still reset the instance even if cleanup fails
      this.recognition = null;
      this.isRecognitionActive = false;
    }
  }

  /**
   * Stop the recognition service safely
   */
  public stopRecognition(): void {
    try {
      console.log('üõë Stopping speech recognition...');
      
      if (this.recognition && this.isRecognitionActive) {
        // Try to stop the recognition
        try {
          this.recognition.stop();
        } catch (error) {
          console.warn('‚ö†Ô∏è Error stopping recognition:', error);
          // Try abort as fallback
          try {
            this.recognition.abort();
          } catch (abortError) {
            console.warn('‚ö†Ô∏è Could not abort recognition either');
          }
        }
      } else {
        console.log('‚ÑπÔ∏è No active recognition to stop');
      }
    } catch (error) {
      console.error('‚ùå Error during recognition stop:', error);
    } finally {
      // Always clean up the instance
      this.cleanupExistingRecognition();
    }
  }

  /**
   * Check if recognition is currently active
   */
  public isActive(): boolean {
    return this.isRecognitionActive;
  }

  /**
   * Restart recognition service after errors
   */
  private restartRecognition = debounce((): void => {
    try {
      console.log('üîÑ Restarting speech recognition...');
      this.stopRecognition();
      setTimeout(() => {
        this.startRecognition();
      }, 500);
    } catch (error) {
      console.error('‚ùå Error restarting recognition:', error);
    }
  }, 1000);

  /**
   * Change the language for recognition
   */
  public changeLanguage(language: string): void {
    this.language = language;
    
    // Restart recognition if it's currently active
    if (this.isRecognitionActive) {
      console.log(`üåç Changing speech recognition language to ${language}`);
      this.restartRecognition();
    }
  }
}
